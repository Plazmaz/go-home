# Warning: These notes are in "thought dump"-style markdown. They contain a lot of rambly nonsense and are not factually correct. I've published them in case I or someone else (god help you) needs to read them. You can send me a message if you find yourself in that positon and I'll try to help you. sorry.
    
Breaking RNG
===
## LFSRs
https://www.eetimes.com/tutorial-linear-feedback-shift-registers-lfsrs-part-1/#
https://github.com/bertrandmartel/lfsr-reverse/blob/master/lfsr_reverse.c


Shift register is similar to a  LIFO queue with set number of slots, each input is shifted one value over when inputted,
so first value sent: A gets slot 0
second value sent: B gets slot 0, A gets slot 1

Linear Feedback Shift Register(LFSR) pulls data from the shift register, modifies it, and feeds it back to input
data input is generated by tap bits being XOR'd or XNOR'd, remaining bits are standard shift register
"A binary field with 'n' bits can assume 2^n unique values, but a maximal-length LFSR with 'n' register bits will only sequence through (2^n â€“ 1) values."
LFSRs with XOR feedback paths will not sequence when all bits are 0, XNOR will not sequence when all bits are 1

(x % y) - (x / y)




Okay so inside of rng they have this logic:
```go
	seed = seed % int32max
	/// False
	if seed < 0 {
		seed += int32max
	}
	/// False
	if seed == 0 {
		seed = 89482311
    }
```
Essentially that turns our seed space from 9223372036854775807 to 9223372036854775807.

rngTap starts at 273, and will cycle back after 273 runs.
Sadly, rng.feed is modified. BUT, we could theoretically cycle through rnglen*2, and look at common values?


IF tap == 0, feed == 334.
IF feed == 0, tap == 273
the value at index `feed` is modified each random value
```go
	rng.tap--
	if rng.tap < 0 {
		rng.tap += rngLen
	}

	rng.feed--
	if rng.feed < 0 {
		rng.feed += rngLen
	}

	x := rng.vec[rng.feed] + rng.vec[rng.tap]
	rng.vec[rng.feed] = x
```


Originally I believed that by looking for common addends between Xn and Xn-1, you could find the value of `tap`, and use that to reverse feed, however I missed the fact that `feed` rolls with `tap`, so it's not the same value either. Assuming that `tap` reaches the previous value of `feed` and modifies it before `feed` rolls back to it (this should be true given the offset of `feed` starts as `607 - 274`, `tap` starts at `607`, and both indices decrement at a constant rate), it will not be possible to recover the value of `feed` using this method.

Actually it's possible the values within the gap between `333` and `606` after the first run won't be modified until the second run.
So I've confirmed this is _almost_ the case. State between `(feed - tap) + 1` and `len ` is not overwritten until `i >= 335`



Attacking service
===
We get one int31 per output

Int31 does seem to mess with information in a rather interesting way. It runs `int32(r.Int63() >> 32)`. However, this did not have the adverse effect I thought it would. I feared this meant we'd lose 32 bits of information. It looks like that's NOT the case. To understand why, let's dive into what happens before that:
1. `rngCooked` and `vec` are assigned to int64s.
2. `rand`'s `Uint64` casts values in both to `uint64`, removing their sign and increasing their max possible value but not actually modifying values.
3. `Int63` runs `int64(rng.Uint64() & rngMask)`, meaning the output of `Uint64` is now either positive or negative, but only `(1 << 63) - 1` in either direction.
4. `Int31` bitshifts `Int63` 32 bits to the right, effectively removing the additional space added in step 2

So what does this mean? We have _not_ lost any information with `Int31`, AND I'm pretty sure golang's `Int63` values are not going to span the whole range of `Int63`, although that warrants further investigation.

Something I noticed: While we are very close with the reconstructed int31 random, the state of that random will not produce negative values


OK SO
WE KNOW THE RATIO HAS TO BE PHI FOR ANY SET OF 3 CANDIDATEs
BUT

----
$$
m = 2,147,483,647\\  
Fib_n = Fib_{n-j}+ Fib_{n-k}\pmod m,0 < j < k \\

A_n = Fib_{n-j} \mod m  \\
B_n = Fib_{n-k} \mod m  \\
C_n = (A_n + B_n) \mod m \\
$$
Given value $c$ in $C$ , find values $x$ and $y$ for $A$ and $B$ where

$$
x + y = c \\
x \mod m = A \\
y \mod m = B \\
x\div y \approxeq \Phi
$$
Should only need to enumerate $m$ space.


----
 $a = S_1 % m$   
  $a = S_1 % int32_max $


$$
(x,y,z) * a

\begin{pmatrix}M & 0 & 0\\
			   a & -1 & 0\\
			   a^2\mod{M} & 0 & -1\\
			 \end{pmatrix}
$$
$a = 2^{31}-1, s_1 = 1105902161, b = 32, r=32$

$Ms_{1}=0 \mod{m}$  
$as_{1}-s_2 = 0 \mod{m}$z
$a^2s_{1}-s_3 = 0 \mod{m}$z

---
$$
\begin{aligned}
	
x_0 &= RNG(seed) = 182605794  \\
x_1 &= 1010111000100101011111100010  \\
o_1 = x_1 << 40 &= 10101110001001010111111000100000000000000000000000000000000000000000  \\
\\...\\
x_2 = RNG(x_1) = 1291394886 &= 000000000000000000001001100111110010001111101000110 \\


o_2 &= o_2 \oplus (x_2 << 20) \\
&= o_2 \oplus 100110011111001000111110100011000000000000000000000 \\
&=10101110001001010011001011011001000111110100011000000000000000000000
\\...\\
x_3 = RNG(x_2) = 1914720637 &= 1110010001000000101000101111101 \\
o = o \oplus x &= 
\end{aligned}
$$